{
  "body_markdown": "## What is this article about?\nWe have all encountered chat over the web, that can be Facebook, Instagram, Whatsapp and the list goes on.\nJust to give a bit of context, you send a message to a person or a group, they see the message and reply back. Simple yet complex.\n\nIn the previous article in this series, we talked about [Socket.io](https://socket.io/), how you can send messages between a React app client and a Socket.io server, how to get active users in your web application, and how to add the \"User is typing...\" feature present in most modern chat applications.\n\nIn this final article, we'll extend the chat application features. You will learn how to keep your users engaged by sending them desktop notifications when they are not online and how you can read and save the messages in a JSON file. However, this is not a secure way of storing messages in a chat application. Feel free to use any database of your choice when building yours.\n\n![Push Notifications](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fovn0h6khei751dl4r26.gif) \n\n## How to send desktop messages to users\n\nHere, I'll guide you through sending desktop notifications to offline users when they have new chat messages.\n\n![Chat](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5kq947hwxmjvlmhrbnm6.png)\n\n## Novu - the first open-source notification infrastructure\nJust a quick background about us. Novu is the first open-source [notification infrastructure](https://novu.co). We basically help to manage all the product notifications. It can be **In-App** (the bell icon like you have in Facebook - **Websockets**), Emails, SMSs and so on.\nI would be super happy if you could give us a star! And let me also know in the comments ‚ù§Ô∏è\nhttps://github.com/novuhq/novu\n\n![Novu](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/yn90yvsd87tgik03c08v.gif)\n\nIn the previous article, we created the `ChatFooter` component containing a form with an input field and a send button. Since we will be sending a notification immediately after a user sends a message, this is where the desktop notifications functionality will exist.\n\n![Chat](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/1oy4v9srqxs4piwrok7v.png) \n\n**Follow the steps below:**\n\nUpdate the `ChatFooter.js` component to contain a function named `checkPageStatus` that runs after a message is sent to the Socket.io server. The function accepts the username and the user's message.\n\n```jsx\nimport React, {useState} from 'react'\n\nconst ChatFooter = ({socket}) => {\n    const [message, setMessage] = useState(\"\")\n    const handleTyping = () => socket.emit(\"typing\",`${localStorage.getItem(\"userName\")} is typing`)\n\n    const handleSendMessage = (e) => {\n        e.preventDefault()\n        if(message.trim() && localStorage.getItem(\"userName\")) {\n        socket.emit(\"message\", \n            {\n            text: message, \n            name: localStorage.getItem(\"userName\"), \n            id: `${socket.id}${Math.random()}`\n            }) \n\t\t\t\t//Here it is üëáüèª\n        checkPageStatus(message, localStorage.getItem(\"userName\")) \n        }}\n        setMessage(\"\")\n    }\n\n    //Check PageStatus Function\n    const checkPageStatus = () => {\n\n    }\n\n  return (\n    <div className='chat__footer'>\n        <form className='form' onSubmit={handleSendMessage}>\n          <input \n            type=\"text\" \n            placeholder='Write message' \n            className='message' \n            value={message} \n            onChange={e => setMessage(e.target.value)}\n            onKeyDown={handleTyping}\n            />\n            <button className=\"sendBtn\">SEND</button>\n        </form>\n     </div>\n  )\n}\n\nexport default ChatFooter\n```\n\nTidy up the `ChatFooter` component by moving the `checkPageStatus` function into a `src/utils` folder. Create a folder named `utils`.\n\n```bash\ncd src\nmkdir utils\n```\n\nCreate a JavaScript file within the `utils` folder containing the `checkPageStatus` function.\n\n```bash\ncd utils\ntouch functions.js\n```\n\nCopy the code below into the `functions.js` file.\n\n```jsx\nexport default function checkPageStatus(message, user){\n\n}\n```\n\nUpdate the `ChatFooter` component to contain the newly created function from the `utils/functions.js` file.\n\n```jsx\nimport React, {useState} from 'react'\nimport checkPageStatus from \"../utils/functions\"\n//....Remaining codes\n```\n\nYou can now update the function within the `functions.js` file as done below:\n\n```jsx\nexport default function checkPageStatus(message, user) {\n    if(!(\"Notification\" in window)) {\n      alert(\"This browser does not support system notifications!\")\n    } \n    else if(Notification.permission === \"granted\") {\n      sendNotification(message, user)\n    }\n    else if(Notification.permission !== \"denied\") {\n       Notification.requestPermission((permission)=> {\n          if (permission === \"granted\") {\n            sendNotification(message, user)\n          }\n       })\n    }\n}\n```\n\nFrom the code snippet above, the [JavaScript Notification API](https://developer.mozilla.org/en-US/docs/Web/API/notification)  is used to configure and display notifications to users. It has three properties representing its current state. They are:\n\n- Denied - notifications are not allowed.\n- Granted - notifications are allowed.\n- Default - The user choice is unknown, so the browser will act as if notifications are disabled. (We are not interested in this)\n\nThe first conditional statement (if) checks if the [JavaScript Notification API](https://developer.mozilla.org/en-US/docs/Web/API/notification) is unavailable on the web browser, then alerts the user that the browser does not support desktop notifications.\n\nThe second conditional statement checks if notifications are allowed, then calls the `sendNotification` function.\n\nThe last conditional statement checks if the notifications are not disabled, it then requests the permission status before sending the notifications.\n\nNext, create the `sendNotification` function referenced in the code snippet above.\n\n```jsx\n//utils/functions.js\nfunction sendNotification(message, user) {\n\n}\nexport default function checkPageStatus(message, user) {\n  .....\n}\n```\n\nUpdate the `sendNotification` function to display the notification's content.\n\n```jsx\n/*\ntitle - New message from Open Chat\nicon - image URL from Flaticon\nbody - main content of the notification\n*/\nfunction sendNotification(message, user) {\n\tconst notification = new Notification(\"New message from Open Chat\", {\n\t  icon: \"https://cdn-icons-png.flaticon.com/512/733/733585.png\",\n\t  body: `@${user}: ${message}`\n\t})\n\tnotification.onclick = ()=> function() {\n\t  window.open(\"http://localhost:3000/chat\")\n\t}\n}\n```\n\nThe code snippet above represents the layout of the notification, and when clicked, it redirects the user to `http://localhost:3000/chat`.\n\nCongratulations!üíÉüèª We've been able to display desktop notifications to the user when they send a message. In the next section, you'll learn how to send alerts to offline users.\n\n<aside>\nüí° Offline users are users not currently viewing the webpage or connected to the internet. When they log on to the internet, they will receive notifications.\n\n</aside>\n\n## How to detect if a user is viewing your web page\n\nIn this section, you'll learn how to detect active users on the chat page via the  [JavaScript Page visibility API](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API). It allows us to track when a page is minimized, closed, open, and when a user switches to another tab.\n\nNext, let's use the API to send notifications to offline users.\n\nUpdate the `sendNotification` function to send the notification only when users are offline or on another tab.\n\n```jsx\nfunction sendNotification(message, user) {\n    document.onvisibilitychange = ()=> {\n      if(document.hidden) {\n        const notification = new Notification(\"New message from Open Chat\", {\n          icon: \"https://cdn-icons-png.flaticon.com/512/733/733585.png\",\n          body: `@${user}: ${message}`\n        })\n        notification.onclick = ()=> function() {\n          window.open(\"http://localhost:3000/chat\")\n        }\n      }\n    }  \n}\n```\n\nFrom the code snippet above, `document.onvisibilitychange` detects visibility changes, and `document.hidden` checks if the user is on another tab or the browser is minimised before sending the notification. You can learn more about the different states [here](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API).\n\nNext, update the `checkPageStatus` function to send notifications to all the users except the sender.\n\n```jsx\nexport default function checkPageStatus(message, user) {\n  if(user !== localStorage.getItem(\"userName\")) {\n    if(!(\"Notification\" in window)) {\n      alert(\"This browser does not support system notifications!\")\n    } else if(Notification.permission === \"granted\") {\n      sendNotification(message, user)\n    }else if(Notification.permission !== \"denied\") {\n       Notification.requestPermission((permission)=> {\n          if (permission === \"granted\") {\n            sendNotification(message, user)\n          }\n       })\n    }\n  }     \n}\n```\n\nCongratulations!üéâ You can now send notifications to offline users.\n\n## Optional: How to save the messages to a JSON \"database\" file\n\nIn this section, you'll learn how to save the messages in a JSON file - for simplicity. Feel free to use any real-time database of your choice at this point, and you can continue reading if you are interested in learning how to use a JSON file as a database.\n\nWe'll keep referencing the `server/index.js` file for the remaining part of this article.\n\n```jsx\n//index.js file\nconst express = require(\"express\")\nconst app = express()\nconst cors = require(\"cors\")\nconst http = require('http').Server(app);\nconst PORT = 4000\nconst socketIO = require('socket.io')(http, {\n    cors: {\n        origin: \"http://localhost:3000\"\n    }\n});\n\napp.use(cors())\nlet users = []\n\nsocketIO.on('connection', (socket) => {\n    console.log(`‚ö°: ${socket.id} user just connected!`)  \n    socket.on(\"message\", data => {\n      console.log(data)\n      socketIO.emit(\"messageResponse\", data)\n    })\n\n    socket.on(\"typing\", data => (\n      socket.broadcast.emit(\"typingResponse\", data)\n    ))\n\n    socket.on(\"newUser\", data => {\n      users.push(data)\n      socketIO.emit(\"newUserResponse\", users)\n    })\n \n    socket.on('disconnect', () => {\n      console.log('üî•: A user disconnected');\n      users = users.filter(user => user.socketID !== socket.id)\n      socketIO.emit(\"newUserResponse\", users)\n      socket.disconnect()\n    });\n});\n\napp.get(\"/api\", (req, res) => {\n  res.json({message: \"Hello\"})\n});\n\n   \nhttp.listen(PORT, () => {\n    console.log(`Server listening on ${PORT}`);\n});\n```\n\n### Retrieving messages from the JSON file\n\nNavigate into the server folder and create a `messages.json` file.\n\n```bash\ncd server\ntouch messages.json\n```\n\nAdd some default messages to the file by copying the code below ‚Äì an array containing default messages.\n\n```json\n\"messages\": [\n        {\n           \"text\": \"Hello!\",\n           \"name\": \"nevodavid\",\n           \"id\": \"abcd01\" \n        }, {\n            \"text\": \"Welcome to my chat application!üíÉüèª\",\n           \"name\": \"nevodavid\",\n           \"id\": \"defg02\" \n        }, {\n            \"text\": \"You can start chatting!üì≤\",\n           \"name\": \"nevodavid\",\n           \"id\": \"hijk03\" \n        }\n    ]\n}\n```\n\nImport and read the `messages.json` file into the `server/index.js` file by adding the code snippet below to the top of the file.\n\n```jsx\nconst fs = require('fs');\n//Gets the messages.json file and parse the file into JavaScript object\nconst rawData = fs.readFileSync('messages.json');\nconst messagesData = JSON.parse(rawData);\n```\n\nRender the messages via the API route.\n\n```jsx\n//Returns the JSON file\napp.get('/api', (req, res) => {\n  res.json(messagesData);\n});\n```\n\nWe can now fetch the messages on the client via the `ChatPage` component. The default messages are shown to every user when they sign in to the chat application.\n\n```jsx\nimport React, { useEffect, useState, useRef} from 'react'\nimport ChatBar from './ChatBar'\nimport ChatBody from './ChatBody'\nimport ChatFooter from './ChatFooter'\n\nconst ChatPage = ({socket}) => { \n  const [messages, setMessages] = useState([])\n  const [typingStatus, setTypingStatus] = useState(\"\")\n  const lastMessageRef = useRef(null);\n\n/**  Previous method via Socket.io */\n  // useEffect(()=> {\n  //   socket.on(\"messageResponse\", data => setMessages([...messages, data]))\n  // }, [socket, messages])\n\n/** Fetching the messages from the API route*/\n    useEffect(()=> {\n      function fetchMessages() {\n        fetch(\"http://localhost:4000/api\")\n        .then(response => response.json())\n        .then(data => setMessages(data.messages))\n      }\n      fetchMessages()\n  }, [])\n\n //....remaining code\n}\n\nexport default ChatPage\n```\n\n### Saving messages to the JSON file\n\nIn the previous section, we created a `messages.json` file containing default messages and displayed the messages to the users. \n\nHere, I'll walk you through updating the `messages.json` file automatically after a user sends a message from the chat page.\n\nUpdate the Socket.io message listener on the server to contain the code below:\n\n```jsx\nsocket.on(\"message\", data => {\n  messagesData[\"messages\"].push(data)\n  const stringData = JSON.stringify(messagesData, null, 2)\n  fs.writeFile(\"messages.json\", stringData, (err)=> {\n    console.error(err)\n  })\n  socketIO.emit(\"messageResponse\", data)\n})\n```\n\nThe code snippet above runs after a user sends a message. It adds the new data to the array in the `messages.json` file and rewrites it to contain the latest update.\n\nHead back to the chat page, send a message, then reload the browser. Your message will be displayed. Open the `messages.json` file to view the updated file with the new entry.\n\n## Conclusion\n\nIn this article, you've learnt how to send desktop notifications to users,  detect if a user is currently active on your page, and read and update a JSON file. These features can be used in different cases when building various applications.\n\nThis project is a demo of what you can build with [Socket.io](http://socket.io/); you can improve this application by adding authentication and connecting any database that supports real-time communication.\n\nThe source code for this tutorial is available here:\n[https://github.com/novuhq/blog/tree/main/build-a-chat-app-part-two](https://github.com/novuhq/blog/tree/main/build-a-chat-app-part-two)\n\n## Help me out!\nIf you feel like this article helped you understand WebSockets better! I would be super happy if you could give us a star! And let me also know in the comments ‚ù§Ô∏è\nhttps://github.com/novuhq/novu\n![Help](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/t7hb7bwof6ou2j6pvjyn.gif)\n \n\nThank you for reading!"
}
