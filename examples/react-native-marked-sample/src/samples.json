{
  "body_markdown_1": "## What is this article about?\nWe have all encountered chat over the web, that can be Facebook, Instagram, Whatsapp and the list goes on.\nJust to give a bit of context, you send a message to a person or a group, they see the message and reply back. Simple yet complex.\n\nIn the previous article in this series, we talked about [Socket.io](https://socket.io/), how you can send messages between a React app client and a Socket.io server, how to get active users in your web application, and how to add the \"User is typing...\" feature present in most modern chat applications.\n\nIn this final article, we'll extend the chat application features. You will learn how to keep your users engaged by sending them desktop notifications when they are not online and how you can read and save the messages in a JSON file. However, this is not a secure way of storing messages in a chat application. Feel free to use any database of your choice when building yours.\n\n![Push Notifications](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/fovn0h6khei751dl4r26.gif) \n\n## How to send desktop messages to users\n\nHere, I'll guide you through sending desktop notifications to offline users when they have new chat messages.\n\n![Chat](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/5kq947hwxmjvlmhrbnm6.png)\n\n## Novu - the first open-source notification infrastructure\nJust a quick background about us. Novu is the first open-source [notification infrastructure](https://novu.co). We basically help to manage all the product notifications. It can be **In-App** (the bell icon like you have in Facebook - **Websockets**), Emails, SMSs and so on.\nI would be super happy if you could give us a star! And let me also know in the comments ‚ù§Ô∏è\nhttps://github.com/novuhq/novu\n\n![Novu](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/yn90yvsd87tgik03c08v.gif)\n\nIn the previous article, we created the `ChatFooter` component containing a form with an input field and a send button. Since we will be sending a notification immediately after a user sends a message, this is where the desktop notifications functionality will exist.\n\n![Chat](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/1oy4v9srqxs4piwrok7v.png) \n\n**Follow the steps below:**\n\nUpdate the `ChatFooter.js` component to contain a function named `checkPageStatus` that runs after a message is sent to the Socket.io server. The function accepts the username and the user's message.\n\n```jsx\nimport React, {useState} from 'react'\n\nconst ChatFooter = ({socket}) => {\n    const [message, setMessage] = useState(\"\")\n    const handleTyping = () => socket.emit(\"typing\",`${localStorage.getItem(\"userName\")} is typing`)\n\n    const handleSendMessage = (e) => {\n        e.preventDefault()\n        if(message.trim() && localStorage.getItem(\"userName\")) {\n        socket.emit(\"message\", \n            {\n            text: message, \n            name: localStorage.getItem(\"userName\"), \n            id: `${socket.id}${Math.random()}`\n            }) \n\t\t\t\t//Here it is üëáüèª\n        checkPageStatus(message, localStorage.getItem(\"userName\")) \n        }}\n        setMessage(\"\")\n    }\n\n    //Check PageStatus Function\n    const checkPageStatus = () => {\n\n    }\n\n  return (\n    <div className='chat__footer'>\n        <form className='form' onSubmit={handleSendMessage}>\n          <input \n            type=\"text\" \n            placeholder='Write message' \n            className='message' \n            value={message} \n            onChange={e => setMessage(e.target.value)}\n            onKeyDown={handleTyping}\n            />\n            <button className=\"sendBtn\">SEND</button>\n        </form>\n     </div>\n  )\n}\n\nexport default ChatFooter\n```\n\nTidy up the `ChatFooter` component by moving the `checkPageStatus` function into a `src/utils` folder. Create a folder named `utils`.\n\n```bash\ncd src\nmkdir utils\n```\n\nCreate a JavaScript file within the `utils` folder containing the `checkPageStatus` function.\n\n```bash\ncd utils\ntouch functions.js\n```\n\nCopy the code below into the `functions.js` file.\n\n```jsx\nexport default function checkPageStatus(message, user){\n\n}\n```\n\nUpdate the `ChatFooter` component to contain the newly created function from the `utils/functions.js` file.\n\n```jsx\nimport React, {useState} from 'react'\nimport checkPageStatus from \"../utils/functions\"\n//....Remaining codes\n```\n\nYou can now update the function within the `functions.js` file as done below:\n\n```jsx\nexport default function checkPageStatus(message, user) {\n    if(!(\"Notification\" in window)) {\n      alert(\"This browser does not support system notifications!\")\n    } \n    else if(Notification.permission === \"granted\") {\n      sendNotification(message, user)\n    }\n    else if(Notification.permission !== \"denied\") {\n       Notification.requestPermission((permission)=> {\n          if (permission === \"granted\") {\n            sendNotification(message, user)\n          }\n       })\n    }\n}\n```\n\nFrom the code snippet above, the [JavaScript Notification API](https://developer.mozilla.org/en-US/docs/Web/API/notification)  is used to configure and display notifications to users. It has three properties representing its current state. They are:\n\n- Denied - notifications are not allowed.\n- Granted - notifications are allowed.\n- Default - The user choice is unknown, so the browser will act as if notifications are disabled. (We are not interested in this)\n\nThe first conditional statement (if) checks if the [JavaScript Notification API](https://developer.mozilla.org/en-US/docs/Web/API/notification) is unavailable on the web browser, then alerts the user that the browser does not support desktop notifications.\n\nThe second conditional statement checks if notifications are allowed, then calls the `sendNotification` function.\n\nThe last conditional statement checks if the notifications are not disabled, it then requests the permission status before sending the notifications.\n\nNext, create the `sendNotification` function referenced in the code snippet above.\n\n```jsx\n//utils/functions.js\nfunction sendNotification(message, user) {\n\n}\nexport default function checkPageStatus(message, user) {\n  .....\n}\n```\n\nUpdate the `sendNotification` function to display the notification's content.\n\n```jsx\n/*\ntitle - New message from Open Chat\nicon - image URL from Flaticon\nbody - main content of the notification\n*/\nfunction sendNotification(message, user) {\n\tconst notification = new Notification(\"New message from Open Chat\", {\n\t  icon: \"https://cdn-icons-png.flaticon.com/512/733/733585.png\",\n\t  body: `@${user}: ${message}`\n\t})\n\tnotification.onclick = ()=> function() {\n\t  window.open(\"http://localhost:3000/chat\")\n\t}\n}\n```\n\nThe code snippet above represents the layout of the notification, and when clicked, it redirects the user to `http://localhost:3000/chat`.\n\nCongratulations!üíÉüèª We've been able to display desktop notifications to the user when they send a message. In the next section, you'll learn how to send alerts to offline users.\n\n<aside>\nüí° Offline users are users not currently viewing the webpage or connected to the internet. When they log on to the internet, they will receive notifications.\n\n</aside>\n\n## How to detect if a user is viewing your web page\n\nIn this section, you'll learn how to detect active users on the chat page via the  [JavaScript Page visibility API](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API). It allows us to track when a page is minimized, closed, open, and when a user switches to another tab.\n\nNext, let's use the API to send notifications to offline users.\n\nUpdate the `sendNotification` function to send the notification only when users are offline or on another tab.\n\n```jsx\nfunction sendNotification(message, user) {\n    document.onvisibilitychange = ()=> {\n      if(document.hidden) {\n        const notification = new Notification(\"New message from Open Chat\", {\n          icon: \"https://cdn-icons-png.flaticon.com/512/733/733585.png\",\n          body: `@${user}: ${message}`\n        })\n        notification.onclick = ()=> function() {\n          window.open(\"http://localhost:3000/chat\")\n        }\n      }\n    }  \n}\n```\n\nFrom the code snippet above, `document.onvisibilitychange` detects visibility changes, and `document.hidden` checks if the user is on another tab or the browser is minimised before sending the notification. You can learn more about the different states [here](https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API).\n\nNext, update the `checkPageStatus` function to send notifications to all the users except the sender.\n\n```jsx\nexport default function checkPageStatus(message, user) {\n  if(user !== localStorage.getItem(\"userName\")) {\n    if(!(\"Notification\" in window)) {\n      alert(\"This browser does not support system notifications!\")\n    } else if(Notification.permission === \"granted\") {\n      sendNotification(message, user)\n    }else if(Notification.permission !== \"denied\") {\n       Notification.requestPermission((permission)=> {\n          if (permission === \"granted\") {\n            sendNotification(message, user)\n          }\n       })\n    }\n  }     \n}\n```\n\nCongratulations!üéâ You can now send notifications to offline users.\n\n## Optional: How to save the messages to a JSON \"database\" file\n\nIn this section, you'll learn how to save the messages in a JSON file - for simplicity. Feel free to use any real-time database of your choice at this point, and you can continue reading if you are interested in learning how to use a JSON file as a database.\n\nWe'll keep referencing the `server/index.js` file for the remaining part of this article.\n\n```jsx\n//index.js file\nconst express = require(\"express\")\nconst app = express()\nconst cors = require(\"cors\")\nconst http = require('http').Server(app);\nconst PORT = 4000\nconst socketIO = require('socket.io')(http, {\n    cors: {\n        origin: \"http://localhost:3000\"\n    }\n});\n\napp.use(cors())\nlet users = []\n\nsocketIO.on('connection', (socket) => {\n    console.log(`‚ö°: ${socket.id} user just connected!`)  \n    socket.on(\"message\", data => {\n      console.log(data)\n      socketIO.emit(\"messageResponse\", data)\n    })\n\n    socket.on(\"typing\", data => (\n      socket.broadcast.emit(\"typingResponse\", data)\n    ))\n\n    socket.on(\"newUser\", data => {\n      users.push(data)\n      socketIO.emit(\"newUserResponse\", users)\n    })\n \n    socket.on('disconnect', () => {\n      console.log('üî•: A user disconnected');\n      users = users.filter(user => user.socketID !== socket.id)\n      socketIO.emit(\"newUserResponse\", users)\n      socket.disconnect()\n    });\n});\n\napp.get(\"/api\", (req, res) => {\n  res.json({message: \"Hello\"})\n});\n\n   \nhttp.listen(PORT, () => {\n    console.log(`Server listening on ${PORT}`);\n});\n```\n\n### Retrieving messages from the JSON file\n\nNavigate into the server folder and create a `messages.json` file.\n\n```bash\ncd server\ntouch messages.json\n```\n\nAdd some default messages to the file by copying the code below ‚Äì an array containing default messages.\n\n```json\n\"messages\": [\n        {\n           \"text\": \"Hello!\",\n           \"name\": \"nevodavid\",\n           \"id\": \"abcd01\" \n        }, {\n            \"text\": \"Welcome to my chat application!üíÉüèª\",\n           \"name\": \"nevodavid\",\n           \"id\": \"defg02\" \n        }, {\n            \"text\": \"You can start chatting!üì≤\",\n           \"name\": \"nevodavid\",\n           \"id\": \"hijk03\" \n        }\n    ]\n}\n```\n\nImport and read the `messages.json` file into the `server/index.js` file by adding the code snippet below to the top of the file.\n\n```jsx\nconst fs = require('fs');\n//Gets the messages.json file and parse the file into JavaScript object\nconst rawData = fs.readFileSync('messages.json');\nconst messagesData = JSON.parse(rawData);\n```\n\nRender the messages via the API route.\n\n```jsx\n//Returns the JSON file\napp.get('/api', (req, res) => {\n  res.json(messagesData);\n});\n```\n\nWe can now fetch the messages on the client via the `ChatPage` component. The default messages are shown to every user when they sign in to the chat application.\n\n```jsx\nimport React, { useEffect, useState, useRef} from 'react'\nimport ChatBar from './ChatBar'\nimport ChatBody from './ChatBody'\nimport ChatFooter from './ChatFooter'\n\nconst ChatPage = ({socket}) => { \n  const [messages, setMessages] = useState([])\n  const [typingStatus, setTypingStatus] = useState(\"\")\n  const lastMessageRef = useRef(null);\n\n/**  Previous method via Socket.io */\n  // useEffect(()=> {\n  //   socket.on(\"messageResponse\", data => setMessages([...messages, data]))\n  // }, [socket, messages])\n\n/** Fetching the messages from the API route*/\n    useEffect(()=> {\n      function fetchMessages() {\n        fetch(\"http://localhost:4000/api\")\n        .then(response => response.json())\n        .then(data => setMessages(data.messages))\n      }\n      fetchMessages()\n  }, [])\n\n //....remaining code\n}\n\nexport default ChatPage\n```\n\n### Saving messages to the JSON file\n\nIn the previous section, we created a `messages.json` file containing default messages and displayed the messages to the users. \n\nHere, I'll walk you through updating the `messages.json` file automatically after a user sends a message from the chat page.\n\nUpdate the Socket.io message listener on the server to contain the code below:\n\n```jsx\nsocket.on(\"message\", data => {\n  messagesData[\"messages\"].push(data)\n  const stringData = JSON.stringify(messagesData, null, 2)\n  fs.writeFile(\"messages.json\", stringData, (err)=> {\n    console.error(err)\n  })\n  socketIO.emit(\"messageResponse\", data)\n})\n```\n\nThe code snippet above runs after a user sends a message. It adds the new data to the array in the `messages.json` file and rewrites it to contain the latest update.\n\nHead back to the chat page, send a message, then reload the browser. Your message will be displayed. Open the `messages.json` file to view the updated file with the new entry.\n\n## Conclusion\n\nIn this article, you've learnt how to send desktop notifications to users,  detect if a user is currently active on your page, and read and update a JSON file. These features can be used in different cases when building various applications.\n\nThis project is a demo of what you can build with [Socket.io](http://socket.io/); you can improve this application by adding authentication and connecting any database that supports real-time communication.\n\nThe source code for this tutorial is available here:\n[https://github.com/novuhq/blog/tree/main/build-a-chat-app-part-two](https://github.com/novuhq/blog/tree/main/build-a-chat-app-part-two)\n\n## Help me out!\nIf you feel like this article helped you understand WebSockets better! I would be super happy if you could give us a star! And let me also know in the comments ‚ù§Ô∏è\nhttps://github.com/novuhq/novu\n![Help](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/t7hb7bwof6ou2j6pvjyn.gif)\n \n\nThank you for reading!",
  "body_markdown_2": "\nHere's an easy implementation of MongoDB in a Discord.JS bot built on Replit! Be sure to follow the steps closely or you might miss something.\n\n## Step 1\n\nCreate a \"models\" folder in your bot, we'll use this to store all the databases in.\n\n## Step 2\n\n**IMPORTANT:** Create a environment variable called `mongodb` and put your database's connection URI in there. It should look something like this: `mongodb+srv://username:password@cluster0.clusters.mongodb.net/?retryWrites=true&w=majority`\n\n_Don't use the example I provided, put your own, it won't work. If you don't have a MongoDB, you can create on at [MongoDB](https://mongodb.com/)_.\n\nIn your **index.js** file, include this:\n\n```js\nconst mongoose = require('mongoose');\n\nmongoose.connect(process.env.mongodb, { useNewUrlParser: true, useUnifiedTopology: true }).then(console.log('Connected to Mongodb.'));\n```\n\nIn the code above, we're connecting to your **MongoDB** database. \n\n## Step 3\n\nBack to the models folder. Create a file in there with any name you want, I'll use \"keys.js\" for my example.\n\nIn the file, import the **schema** which you'll use later on.\n\n```js\nconst mongo = require('mongoose');\n\nconst Schema = new mongo.Schema({\n  Guild: Number,\n  SpecialKey: String\n});\n```\n\nHere, we're specifying the basic schema that we'll use for the database. **You can change this to fit your bot's functionalities.** \n\nFinally, export the schema as follows:\n\n```js\nmodule.exports = mongo.model('yourdatabasename', Schema);\n```\n\nAdd that to the bottom of the file! üòÉ\n\n> If you don't know how to make your own schema, you can view some examples [here](https://mongoosejs.com/docs/guide.html).\n\n## Step 4\n\nThis is the **final step**! Go to your bot's command cog you want to use the database in and follow these steps:\n\nImport the database:\n\n```js\nconst Schema = require('../../models/keys.js'); // Example\n```\n\nThen in your command, you can fetch values as follows:\n\n```js\nSchema.findOne({ Guild: interaction.guild.id }, async (err, data) => {\n  if (data) {\n    respond({\"content\": `This server's special key is: ${data[\"SpecialKey\"]}!`});\n  } else {\n    new Schema ({\n      Guild: interaction.guild.id,\n      SpecialKey: \"Examples ‚ú®\"\n    }).save()\n    \n    respond({\"content\": `Woah! This server doesn't have a key yet üëÄ I've just set yours to the default key instead!`});\n  }\n});\n```\n\n## Editing and Deleting Data\n\nIf this post does well, I'll do a follow-up one with a tutorial on how to edit data, delete data and more. \n\n‚û°Ô∏è If you found this post helpful, please give it a üëç, **Thank you!**\n\n‚ö°Ô∏è Do you want an **advanced invite tracker** in your discord server? Consider adding my verified bot, **[Ayami](https://discord.com/api/oauth2/authorize?client_id=1012917274908311552&permissions=0&scope=bot%20applications.commands)**!",
  "body_markdown_3": "Most businesses run around the concept of appointments. Appointments allow you to schedule different events for different individuals. For example, before seeing a doctor, it might be necessary to book an appointment. Businesses can leverage the power of WhatsApp to allow their customers to book appointments easily just by sending messages. They can also get updates or check the status of their appointments through WhatsApp messages.\n\nIn this tutorial, you‚Äôll learn to use Twilio‚Äôs WhatsApp API with the Notion API and FastAPI to create appointments and get their statuses as well. You will use Notion for storing data, Twilio for sending WhatsApp messages, and FastAPI for API and business logic.\n\nRead the full blog on [Twilio](https://www.twilio.com/blog/booking-appointments-twilio-notion-fastapi).\n\nThanks for reading üíú\n\n---\n\nI publish a [monthly newsletter](https://www.ravsam.in/newsletter/) in which I share personal stories, things that I am working on, what is happening in the world of tech, and some interesting dev-related posts which I come across while surfing the web.\n\nConnect with me through [Twitter](https://twitter.com/ravgeetdhillon) ‚Ä¢ [LinkedIn](https://linkedin.com/in/ravgeetdhillon) ‚Ä¢ [GitHub](https://github.com/ravgeetdhillon) or send me an [Email](mailto:ravgeetdhillon@gmail.com).\n\n‚Äî [Ravgeet](https://www.ravgeet.in/), *Full Stack Developer and Technical Content Writer*",
  "body_markdown_4": "I've wanted to optimize my website even more for the longest time.\n\n---\n\nEvery weekend I try to dedicate some time to see where I can optimize it even more.\n\nThis weekend it was all around CSS loading.\nIt's already pretty optimized, and there were only two items I could think of.\n\n- Page by page loads\n- Preloading stylesheets\n\n## Page by page loads\n\nUnfortiuonally, this is not supported with Tailwind in Astro as we get one generic output CSS.\nFor my website, it doesn't make the biggest difference as the post pages only have a couple of lines of extra CSS compared to the homepage.\n\nHowever, still looking at how I can optimize what's used even more.\n\n**Conclusion**: Nothing to optimize for a quick win. More research is needed.\n\n## Preloading stylesheets\n\nI wasn't sure if this one would help, but we could declare the main stylesheet as important by adding a `rel=\"preload\"` link.\nThis would indicate that the page should try and fetch this with the most priority.\n\nIt sounded easy to try out, but it took a lot of research and trying out things.\n\nI went over the Astro docs and found out you can load the stylesheets as a plain URL by appending a `?url` parameter.\n\nThen, we can load it directly like this:\n\n```js\n---\nimport stylesUrl from '../styles/main.css?url';\n---\n<link rel=\"preload\" href={stylesUrl} as=\"style\">\n<link rel=\"stylesheet\" href={stylesUrl}>\n```\n\nThe dev version worked perfectly, but then I tried outputting this as a build, and I noticed it base64 encoded the whole CSS file.\n\nIt is documented in the docs this can happen, and we have to disable this Vite config.\nI added the following to my `astro.config.mjs` file:\n\n```js\nexport default defineConfig({\n  vite: {\n    build: {\n      assetsInlineLimit: 0,\n    },\n  },\n});\n```\n\nI reran my build output and ended up with a compiled CSS like this:\n\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n.some-of-my-custom-css {\n  // ...\n}\n```\n\nUgh, not really what I wanted as our Tailwind is not processed now.\n\nI took one of my existing build compiled CSS files for option three and put them in my project.\n\n> Note: My CSS doesn't ever change, so that it could be a viable option.\n\nI changed my imports to load this CSS file, and voila, it worked!\n\nEagerly I went to try my tests again to see how fast it was loading.\nTo my disappointment, it went backward. It now took another 2ms longer to load the first byte.\n\nAnd thus, back to the drawing board with CSS optimizations.\n\n## Conclusion\n\nSometimes you might have put a lot of work into something that does not work as you expected.\n\nIt's totally fine, and it happens to everyone.\nAt least you learned something, and you tried it out.\n\nI generally don't write as much about my failed experiments, but I thought it might help other people not to feel bad when something doesn't work on the first try.\n\n### Thank you for reading, and let's connect!\n\nThank you for reading my blog. Feel free to subscribe to my email newsletter and connect on [Facebook](https://www.facebook.com/DailyDevTipsBlog) or [Twitter](https://twitter.com/DailyDevTips1)"
}
